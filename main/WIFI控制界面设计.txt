设备启动后向局域网广播一条UDP消息，
“I'm here with esp32.Where is my friend?I'm {device_name}"
{device_name}为1个32Ascii字符的字符串。为设备用户名
服务器收到后根据IP回复设备。并回复服务器端IP和端口，建立TCP连接。

服务器和设备只能由服务器发出主动消息。
设备收到命令后，执行命令等操作，然后给服务器发送回复（如果有的话，每个命令最大执行时间3秒，服务器等待3秒没有收到回复，则认为超时，命令执行失败）。
设备上运行一个任务。拥有一个命令队列，专门等待服务器的命令，将服务器发送来的命令依次放入队列中，支持一个最高优先级。当收到最高优先级命令时，使用优先任务执行该命令，优先任务比当前任务优先级高
会打断当前任务执行，首先执行。
收到命令后，根据命令内容设置一个标志。
命令是否支持被取消。即一个命令尚未发送回复之前，是否可以接受下一个命令。（可以接受下一个命令，但当前任务执行完毕后才去命令队列取下一个命令执行）
有两个任务，一个叫当前任务，一个叫优先任务。优先任务的优先级高，当解析到一条命令带优先级概念时，放入优先级命令队列，否则，放入当前任务队列，出现优先级任务时，立即中断当前任务执行，进行任务调度以执行
优先级任务。


是否要把命令接受任务和任务执行分开？如果在一起。执行为结束任任务执行时间很短。似乎也可以放在一起。执行完一个任务后再取读取下一个命令。要实现任务执行可以被终止似乎很困难，这涉及任务资源清理。但又似乎
做得到。对一些不为NULL的资源进行清理。然后将清理代码放务的动作后，就执行资源清理。
执行命令似乎需要长时间的循环，或者借助定时器进行操作

先想想有什么命令
终止与当前服务器的连接并重新搜索服务器
当前服务器退出该怎么办（或者意外失去连接？应该检测多少次通讯失败后，就认为失去该服务器连接，是否采用心跳包来检测是否失去连接）
输出一个波以指定的参数
中止当前波的输出
重新输出一个波，以新的参数
扫频？
示波器应用？？？（需要实时不间断及时传输）暂时不要支持这个


快速迭代写代码？先写一些已知的，实验性的代码。然后再改进？


ESP32作为客户端进行UDP广播。
服务端绑定0.0.0.0及指定端口进行UDP接受。
收到客户端连接请求后提示用户是否进行连接。
这种通信量很少的通讯是否改用UDP进行全程通信。在应用层加上可靠传输检测（要求应答信号）。
然后使用UDP心跳包来判断两者连接是否正常。
客户端和服务端都可以主动断开连接。
然后客户端和服务端都可以检测通讯超时，判断对方掉线。
为减轻ESP32负担，心跳包由服务端发送。ESP32只要不断接受心跳包，判断接受时间是否超时即可。

如果又两个线程分别发送心跳包，则可能出现发送冲突，可以排队进入一个队列，只由一个线程
进行发送
接受也是如此，只由一个线程接受。然后判断是属于什么性质的包，谁是消费者，而把数据推送给
相关消费者

20MS左右的系统响应时间对这个应用应该足够了。

一个线程进行接受，接受后需要进行应答，对于心跳包简单回复编号。对于命令包要回复数据。
似乎有些数据量也不小，还是使用TCP进行通讯？
主要是示波器式的应用。此时是否可以开启新的TCP连接？
如果不支持示波器模式，则暂时对数据量和延时的要求都不高。可以用UDP模拟。
接收和发送UDP的操作是否放在一个线程里面？

如果接收到命令包，则心跳包正常发送，但是开始命令回复超声计时（这个超声时间相对心跳包长一点）
心跳包每500MS由服务器发送一次。心跳包也需要回复。则两边都是一发一收，也无所谓谁是主动发送
心跳包超时为2S，即连续4个心跳包收不到。就认为对方掉线。





